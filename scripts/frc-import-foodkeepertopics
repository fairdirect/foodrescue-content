#!/usr/bin/env ruby
# NOTE: Above shebang selects the first Ruby found in $PATH and is standard practice to work with 
# multiple installed versions and version switchers like chruby; see https://stackoverflow.com/a/2792076

# Suppress depreciation warnings from the awesome_print gem.
# @todo Fix the gem, then remove this.
$VERBOSE = nil

# Gem includes. See Gemfile.
require 'docopt'
require 'sqlite3'
require 'csv'
require 'ox'
require 'awesome_print'

# Local, non-gem includes.
require_relative '../lib/database'
require_relative '../lib/topic'


#############################################################################
# UTILITIES

version = '0.1'

# Command line documentation that's also the spec for a command line parser.
# 
# Format specs: http://docopt.org/
# Library docs: https://github.com/docopt/docopt.rb
doc = <<DOCOPT
Converts the content from the USDA FoodKeeper Android app to SQLite3 format.

The script reads the FoodKeeper database from FK_DB and writes its output to 
the food rescue content database FRC_DB. Both databases are in SQLite3 format. The script 
also expects a CSV file CSV_FILE with columns "FoodKeeper Product ID", "Food Rescue Categories" 
(which is a multi-value field) and "Food Rescue Topic Intro".

Full process to convert FoodKeeper data:

1. Obtain the .apk file of FoodKeeper on your desktop computer. The FoodKeeper app 
   is linked from the FoodKeeper website (https://www.foodsafety.gov/keep-food-safe/foodkeeper-app).
   A good, cross-platform option is using Raccoon (https://raccoon.onyxbits.de/).
2. Unzip the APK package: 
   unzip decode gov.usda.fsis.foodkeeper2-46.apk
4. Get the database out of the decoded files:
   cp gov.usda.fsis.foodkeeper2-46/assets/databases/foodkeeper.db FoodKeeper.sqlite3
5. Run this script to convert the database to DocBook XML topics.

Examples: For the foodrescue-content repo, the command to run is:

  scripts/frc-import-foodkeepertopics \
    content-topics/FoodKeeper.sqlite3 \
    content-topics/topics-foodkeeper-en/topic-foodkeeper-

Usage:
  #{__FILE__} FK_DB CSV_FILE FRC_DB
  #{__FILE__} -h | --help
  #{__FILE__} -v | --version

Options:
  -h, --help                     Show this screen.
  -v, --version                  Show version.

DOCOPT


# ## Table structure of the FoodKeeper App database
#
# * **FOOD_CATEGORY, FOOD_CATEGORY_ES, FOOD_CATEGORY_PT.** The 25 main and sub categories of food found on the app's start 
#   screen. Not all categories have sub-categories, but if one has them, then products can not be in the main category.
# * **PRODUCTS, PRODUCTS_ES, PRODUCTS_PT.** The main table with all storage durations and instructions for 396 products. 
#   Products are rather types of products. There is one table per language, where all tips and other texts are translated and 
#   all numbers appear redundantly. Translation is complete.
# * **COOKING_METHODS, COOKING_METHODS_ES, COOKING_METHODS_PT.** Cooking instructions for 89 products. Could be part of 
#   PRODUCTS since it's a 1:1 relation. One table per language, but only the "Cooking_Method" column is really a free-text 
#   field that needs translation.
# * **COOKING_TIPS, COOKING_TIPS_ES, COOKING_TIPS_PT.** 93 cooking tips including a free-text column, a safe minimum 
#   temperature (in Fahrenheit), and a rest time. Some tips are identical because this table is not normalized.
# * **FAVORITE_PRODUCTS.** The user's heart-marked products in the app. Not relevant.
# * **SEARCH_HISTORY.** The user's search history in the app. Not relevant.
# * **RECALLS.** Product recalls. Not relevant.
# 
#
# ## Column structure of the PRODUCTS table in the FoodKeeper App database
# 
# * **Name.** Defines the general type of product.
# * **Name_subtitle.** An optional, more detailed definition of the type of product, used esp. where "Name" is identical for 
#   several products.
# * **\*_Min, \*_Max, \*_Metric.** The storage duration range for a specific storage type. The `_Metric` column contains the 
#   unit ("Days", "Weeks" etc.).
# * **Pantry_(Min|Max|Metric).** The "general" pantry storage, independent of whether the package is already opened or not. 
#   Only 6 products have this. A value here is mutually exclusive with a value in any of the other two pantry storage types.
# * **DOP_Pantry_(Min|Max|Metric).** Storage in the pantry from the date of purchase. Without opening the package, as otherwise 
#   also having the "pantry after opening" storage type would make no sense. Products can have values heere and in the "pantry 
#   after opening" columns at the same time.
# * **Pantry_After_Opening_(Min|Max|Metric).** Values can appear here in addition to `DOP_Pantry_(Min|Max|Metric)`.
# 
# For the refrigeration and freezing related columns, the same relationship between columns applies as for the pantry storage 
# related columns.
# 
# * **Pantry_tips, Refrigerate_tips, Freeze_Tips.** These are the only relevant columns with tips. The columns `DOP_*_tips` are 
#   all empty, and other tips columns do not even exist. Logically, some tips here refer storage types stored in other columns 
#   than `Pantry_*`, `Refrigerate_*` or `Freeze_*`, for example the tip "After opening time applies to prepared product.". So 
#   these tips should be rendered once for the whole list of pantry, refrigerator or freezer storage instructions, as they seem 
#   to apply to the whole list.
# * **DOP_Pantry_tips, DOP_Refrigerate_tips, DOP_Freeze_Tips.** These columns are completely empty, see:
#   `SELECT ID, DOP_Pantry_tips FROM PRODUCTS WHERE DOP_Pantry_tips != '';`
# 
# All columns are of data type "TEXT".
# 
#
# ## Other observations about the FoodKeeper App
# 
# * The app is 94 MiB in size and basically all of that is consumed by high-dpi stock images in PNG format (!), used in the app 
#   in the background.
# * The database is only 280 kiB, and even that contains redundancy due to the way how translations, cooking methods and 
#   cooking tips are saved. And because each column has a SQLite3 ROWID column. 120 kiB would be achievable easily.
# 
#
# ## Remaining work for future extensions
# 
# @todo (later) Refactor code in this script into a class FoodKeeperDatabase, stored in the same file in this script (because 
#   it is not re-usable).
# @todo (later) Normalize the FoodKeeper database column names: `_tips` should be `_Tips` everywhere.
# @todo (later) Make this script downloading the FoodKeeper .apk file from Google Play, using a command like Raccoon.
# @todo (later) Also include extracting the FoodKeeper database from the .apk file. Probably, a simple unzip command (of only 
#   the SQLite database) will be sufficient, with no need for apktool.
# @todo (later) As an alternative to the above, include a SQL command dump of the FoodKeeper database into the Git repository, 
#   and enable this script to read it as an alternative to being provided a binary SQLite database file. The SQL dump format is 
#   better manageable for Git.


# Create and populate a database table with a mapping between FoodKeeper products and Food Rescue Database categories.
# 
# @param catmap_path [String]  Path to the CSV file with the category mapping. Expected columns: "FoodKeeper Product ID" and 
#   "Food Rescue Categories".
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database. The category mapping refers to product 
#   records in this database by ID.
def import_food_rescue_categories(catmap_path, db)

  # Let the OS sync write operations to the database file when it wants rather than after each command.
  # 
  # Reason: "Commits can be orders of magnitude faster with synchronous OFF" as per 
  # https://sqlite.org/pragma.html#pragma_synchronous and we don't care here about database corruption on power outage. 
  # Because it can be simply generated anew by running the import scripts again.
  db.execute 'PRAGMA synchronous = OFF'

  # Create the database table for the category mapping.
  db.execute '
    CREATE TABLE IF NOT EXISTS FOOD_RESCUE_CATEGORIES (
      Product_ID    INTEGER,
      Category_Name TEXT,
      ----
      PRIMARY KEY   (Product_ID, Category_Name)
    )'

  # Import the category mapping from the CSV file.
  CSV.foreach(catmap_path, { headers: true }) do |row|
    foodkeeper_id = row['FoodKeeper Product ID']
    cat_names = row['Food Rescue Categories']&.split("\n")

    next if cat_names.nil? or cat_names.empty? # Do not import incomplete data.
    
    cat_names.each do |cat_name|
      db.execute \
        'INSERT INTO FOOD_RESCUE_CATEGORIES (Product_ID, Category_Name) VALUES (?, ?)', 
        [foodkeeper_id, cat_name]
    end
  end

  # Restore synchronous operation, which was disabled at the start of the method.
  db.execute 'PRAGMA synchronous = ON'
end


# Import additional hints to specify the FoodKeeper product more precisely than by category, where needed.
# 
# @param csv_path [String]  Path to the CSV file with the category mapping. Expected columns: "FoodKeeper Product ID" and 
#   "Food Rescue Topic Intro".
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database. The category mapping refers to product 
#   records in this database by ID.
def import_food_rescue_topic_intro(csv_path, db)

  # Let the OS sync write operations to the database file when it wants rather than after each command.
  # 
  # Reason: "Commits can be orders of magnitude faster with synchronous OFF" as per 
  # https://sqlite.org/pragma.html#pragma_synchronous and we don't care here about database corruption on power outage. 
  # Because it can be simply generated anew by running the import scripts again.
  db.execute 'PRAGMA synchronous = OFF'

  # Create the database table for the category mapping.
  db.execute 'ALTER TABLE PRODUCTS ADD COLUMN Topic_Intro TEXT'

  # Import the topic intro texts from the CSV file.
  CSV.foreach(csv_path, { headers: true }) do |row|
    foodkeeper_id = Integer(row['FoodKeeper Product ID'])
    topic_intro = row['Food Rescue Topic Intro']

    next if topic_intro.nil? or topic_intro.empty?
    
    db.execute 'UPDATE PRODUCTS SET Topic_Intro = ? WHERE ID = ?', [topic_intro, foodkeeper_id]
  end

  # Restore synchronous operation, which was disabled at the start of the method.
  db.execute 'PRAGMA synchronous = ON'
end


# Determine the Open Food Facts categories for this FoodKeeper product.
# 
# The mapping conveniently relies on a table `FOOD_RESCUE_CATEGORIES` that has to be added to the FoodKeeper database and populated before
# calling. See `#import_food_rescue_categories`.
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product for which to determine the food rescue 
#   categories.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [Array<String>]  The OFF categories, using their full English names. Only when no English name is available, a name in
#   a different language would be used, with a two-letter language prefix such as "fr:French Category Name Here".
def categories(product_id, db)
  db
    .execute('SELECT Category_Name FROM FOOD_RESCUE_CATEGORIES WHERE Product_ID = ?', [ product_id ])
    .collect { |row| row['Category_Name'] }
end


# Create a basic topic and fill in the values common for all FoodKeeper topics.
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [FoodRescue::Topic]  The basic topic that has been created.
def basic_topic(product_id, db)
  topic = FoodRescue::Topic.new

  # Author information about the FoodKeeper app.
  # 
  # Since the original FoodKeeper content appears both on a website and mobile apps and it was not clear who its original 
  # author is, both the app author and website author are credite. The author of the food-rescue-content software is included 
  # as in role "conversion", as the final form of the reused FoodKeeper content is defined by the foodrescue-content software.
  # 
  # Author information about the FoodKeeper app as per:
  # 
  # * https://play.google.com/store/apps/details?id=gov.usda.fsis.foodkeeper2
  # * https://www.fsis.usda.gov/wps/portal/informational/contactus
  # 
  # Author information about the (identical) FoodKeeper web content as per:
  # 
  # * https://www.foodsafety.gov/keep-food-safe/foodkeeper-app
  # * https://www.foodsafety.gov/about
  topic.authors = [
    {
      role:       'author',
      orgname:    'United States Department of Agriculture',
      orgdiv:     'Food Safety and Inspection Service',
      uri:        'https://www.fsis.usda.gov/'
    },
    {
      role:       'author',
      orgname:    'United States Department of Health & Human Services',
      orgdiv:     'Web Communications and New Media Division',
      uri:        'https://www.hhs.gov/'
    },
    {
      role:       'conversion',
      givenname:  'Matthias',
      surname:    'Ansorg',
      orgname:    'Fairdirect e.V.'
    }
  ]

  # As of 2020-05-02, the topic's version date is the "Updated" date of the FoodKeeper app on Google Play. The website notes 
  # however "Date Last Reviewed: April 26, 2019", so might contain more recent updates.
  # See: https://www.foodsafety.gov/keep-food-safe/foodkeeper-app
  topic.edition = '2017-11-14'

  # Fill the topic's Open Food Facts categories.
  topic.categories = categories(product_id, db)

  # No abstract by default because FoodKeeper topics are very short already.
  # Of course the value can be overwritten as needed after this function returned.
  topic.abstract = '' 

  topic.content_xbibrefs = [ {id: 'USDA-1', ref_details: "PRODUCTS.ID=#{product_id}"} ]
  topic.bibliography = ['USDA-1']

  return topic
end

# Determine what storage types are defined for a given FoodKeeper product.
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the given product.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [Array<Symbol>]  The storage types defined for this product. Contained values can be or or more of `:pantry`, 
#   `:refrigerator`, `:freezer`. 
def storage_types(product_id, db)

  # Database column name prefixes and the three storage types they belong to.
  storage_type_prefixes = {
    pantry:       [ 'Pantry',      'DOP_Pantry',      'Pantry_After_Opening'                                   ],
    refrigerator: [ 'Refrigerate', 'DOP_Refrigerate', 'Refrigerate_After_Opening', 'Refrigerate_After_Thawing' ],
    freezer:      [ 'Freeze',      'DOP_Freeze'                                                                ]
  }

  product = db.get_first_row('SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ])

  storage_types = []
  storage_type_prefixes.each do |storage_type, field_prefixes|
    field_prefixes.each do |prefix|
      # If a storage duration is defined in the #{prefix} database column, the corresponding 
      # storage type is defined for this product.
      unless shelf_life(product_id, db, prefix).empty?
        storage_types << storage_type
        next
      end
    end
  end

  return storage_types
end

# Render the specified product's shelf life into a string like "6-9 Months".
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @param field_prefix [String]  The prefix of the FoodKeeper database columns (in table PRODUCTS) to use when rendering the 
#   shelf life string. For example, `Pantry`.
# @return [String]  The shelf life string. It may contain XML, so must be added as raw content to an XML file. It may be the 
#   empty string if no information is present.
# 
# @todo Rename to better differentiate from #storage_durations.
def shelf_life(product_id, db, field_prefix)
  product = db.get_first_row('SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ])

  fields = product.select { |k,v| k.match(/^#{field_prefix}_(Min|Max|Metric)$/) }

  min_duration = product["#{field_prefix}_Min"]
  max_duration = product["#{field_prefix}_Max"]
  duration_metric = product["#{field_prefix}_Metric"]

  text_after = case field_prefix
    when 'Pantry';                      'in the pantry, whether sealed or not'
    when 'DOP_Pantry';                  'in the pantry, if still sealed'
    when 'Pantry_After_Opening';        'in the pantry, after opening the package'
    when 'Refrigerate';                 'in the fridge, whether sealed or not'
    when 'DOP_Refrigerate';             'in the fridge, if stored there immediately after purchase, whether sealed or not'
    when 'Refrigerate_After_Opening';   'in the fridge, if stored there after opening the package'
    when 'Refrigerate_After_Thawing';   'in the fridge, if stored there after thawing a frozen item, whether sealed or not'
    when 'Freeze';                      'in the freezer, whether sealed or not'
    when 'DOP_Freeze';                  'in the freezer, if stored there immediately after purchase, whether sealed or not'
  end

  if min_duration.empty?
    ""
  elsif min_duration == max_duration
    "<emphasis>#{min_duration} #{duration_metric}</emphasis> #{text_after}"
  else
    # An en dash, like here, is the correct typography for a range. See:
    # https://en.wikipedia.org/wiki/Dash#Ranges_of_values
    "<emphasis>#{min_duration}–#{max_duration} #{duration_metric}</emphasis> #{text_after}"
  end
end


# Render the specified product's storage tips into a string.
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @param storage_type [Symbol]  The storage type to generate instructions for. Any of `:pantry`, `:refrigerator`, `:freezer`. 
#   If omitted, instructions for all storage types are included.
# @return [String]  The storage tips string, which can be the empty string.
def storage_tips(product_id, db, storage_type: nil)
  product = db.get_first_row('SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ])

  # Note that tips fields are either named `*_Tips` or `*_tips`. It should be `*_Tips` everywhere, as SQLite3 column names 
  # are case-independent, this sloppyness is tolerated in the database. But not for the hash keys here.
  case storage_type
  when :pantry
    product['Pantry_tips']
  when :refrigerator
    product['Refrigerate_tips']
  when :freezer
    product['Freeze_Tips']
  when nil
    "#{product['Pantry_tips']} #{product['Refrigerate_tips']} #{product['Freeze_Tips']}"
  end
end


# Generate a list of storage instructions in XML for the specified product.
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @param storage_type [Symbol]  The storage type to generate instructions for. Any of `:pantry`, `:refrigerator`, `:freezer`.
#   If omitted, instructions for all storage types are included.
# @param include_tips [Boolean]  Whether to also include more detailed storage tips, or just show storage durations.
# @return [Ox::Element]
def storage_durations(product_id, db, storage_type: nil, include_tips: true)
  # Field / column prefixes by storage type. 
  field_prefixes = {
    pantry:       [ 'Pantry',      'DOP_Pantry',      'Pantry_After_Opening'                                   ],
    refrigerator: [ 'Refrigerate', 'DOP_Refrigerate', 'Refrigerate_After_Opening', 'Refrigerate_After_Thawing' ],
    freezer:      [ 'Freeze',      'DOP_Freeze'                                                                ]
  }
  field_prefixes[nil] = field_prefixes.values.flatten # All if storage type not given.

  instructions = Ox::Element.new('itemizedlist')
  selected_prefixes = field_prefixes[storage_type]

  selected_prefixes.each do |prefix|
    instruction = shelf_life(product_id, db, prefix) 
    instructions << (
      Ox::Element.new('listitem') << (Ox::Element.new('simpara') << Ox::Raw.new(instruction))
    ) unless instruction.empty?
  end

  return instructions
end


# Generate an introductory sentence for the list of estimated storage durations.
# 
# The topic intro text is "The typical storage life is: " or, where column `FOOD_RESCUE_CATEGORIES.Topic_Intro` provides a text to 
# specify the food items more precisely than the assigned categories can, someting like For dried herbs, the storage duration 
# is …".
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [String]
# @see #import_food_rescue_categories Where the data is imported that this method needs.
# 
# @todo Rename to #content_intro, in analogy to the naming in class Topic.
def topic_intro_text(product_id, db)
  product = db.get_first_row('SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ])

  return "The typical storage life is:" if product['Topic_Intro'].nil? or product['Topic_Intro'].empty?
  return "#{product['Topic_Intro']}, the typical storage life is:"
end


# Generate a closing sentence for the list of estimated storage durations.
#
# The closing sentence tells in most detail to which products this food rescue topic relates and is meant for teh user to be 
# able to spot categorization errors etc..
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [String]
# @see #import_food_rescue_categories Where the data is imported that this method needs.
# 
# @todo Rename to #content_outro, in analogy to the naming in class Topic.
def topic_outro_text(product_id, db)
  product  = db.get_first_row 'SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ]
  category = db.get_first_row 'SELECT * FROM FOOD_CATEGORY WHERE ID = ?', [ product['Category_ID'] ]

  full_name = [category['Category_Name'], category['Subcategory_Name'], product['Name']].join(': ')
  full_name = "#{full_name} (#{product['Name_subtitle']})" unless product['Name_subtitle'].empty?
  
  return "(The above applies to: '#{full_name}'.)"
end


# Create a topic from given FoodKeeper product data with an overview of shelf life information.
# 
# This is currently unused. It was for a now-defunct content section "Storage Overview".
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [FoodRescue::Topic]  The created topic.
def storage_overview_topic(product_id, db)
  product = db.get_first_row('SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ])

  topic = basic_topic(product_id, db)
  topic.title = 'Storage Durations'
  topic.section = 'storage_overview'

  intro = Ox::Element.new('simpara') << topic_intro_text(product_id, db)
  list = storage_durations(product_id, db, include_tips: false)
  outro = Ox::Element.new('simpara') << topic_outro_text(product_id, db)
  topic.content_proper = Ox::Document.new << intro << list << outro

  return topic
end


# Create a topic from given FoodKeeper product about pantry storage.
# 
# @param product_id [Integer]  The FoodKeeper database's PRODUCTS.ID value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [FoodRescue::Topic]  The created topic.
def pantry_storage_topic(product_id, db)
  topic = basic_topic(product_id, db)
  topic.title = 'Pantry storage'
  topic.section = 'pantry_storage'

  intro = Ox::Element.new('simpara') << topic_intro_text(product_id, db)
  list = storage_durations(product_id, db, storage_type: :pantry)
  tips = storage_tips(product_id, db, storage_type: :pantry)
  tips = Ox::Element.new('simpara') << tips unless tips.empty?
  outro = Ox::Element.new('simpara') << topic_outro_text(product_id, db)

  topic.content_proper = Ox::Document.new << intro << list << tips << outro
  return topic
end


# Create a topic from given FoodKeeper product about refrigerated storage.
# 
# @param product_id [Integer]  The FoodKeeper database's `PRODUCTS.ID` value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [FoodRescue::Topic]  The created topic.
def refrigerator_storage_topic(product_id, db)
  topic = basic_topic(product_id, db)
  topic.title = 'Fridge storage'
  topic.section = 'refrigerator_storage'

  intro = Ox::Element.new('simpara') << topic_intro_text(product_id, db)
  list = storage_durations(product_id, db, storage_type: :refrigerator)
  tips = storage_tips(product_id, db, storage_type: :refrigerator)
  tips = Ox::Element.new('simpara') << tips unless tips.empty?
  outro = Ox::Element.new('simpara') << topic_outro_text(product_id, db)

  topic.content_proper = Ox::Document.new << intro << list << tips << outro
  return topic
end


# Create a topic from given FoodKeeper product about freezer storage.
# 
# @param product_id [Integer]  The FoodKeeper database's `PRODUCTS.ID` value of the product about which the topic will be about.
# @param db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @return [FoodRescue::Topic]  The created topic.
def freezer_storage_topic(product_id, db)
  topic = basic_topic(product_id, db)

  topic.title = 'Freezer storage'
  topic.section = 'freezer_storage'

  intro = Ox::Element.new('simpara') << topic_intro_text(product_id, db)
  list = storage_durations(product_id, db, storage_type: :freezer)
  tips = storage_tips(product_id, db, storage_type: :freezer)
  tips = Ox::Element.new('simpara') << tips unless tips.empty?
  outro = Ox::Element.new('simpara') << topic_outro_text(product_id, db)

  topic.content_proper = Ox::Document.new << intro << list << tips << outro
  return topic
end


# Import a single FoodKeeper product to the SQLite3 database.
# 
# @param product_id [Integer]  The FoodKeeper database's `PRODUCTS.ID` value of the product about which the topic will be about.
# @param fk_db [SQLite3::Database]  The database connection to the FoodKeeper database.
# @param frc_db [FoodRescue::Database]  The database connection to the database with food rescue content.
def import_product(product_id, fk_db, frc_db)
  product = fk_db.get_first_row('SELECT * FROM PRODUCTS WHERE ID = ?', [ product_id ])
  storage_types = storage_types(product_id, fk_db)

  topics = []
  topics << pantry_storage_topic(product_id, fk_db)       if storage_types.include? :pantry
  topics << refrigerator_storage_topic(product_id, fk_db) if storage_types.include? :refrigerator
  topics << freezer_storage_topic(product_id, fk_db)      if storage_types.include? :freezer

  # @todo (later) Create and write a topic for the "Preparation Instructions" section.
  # (Using the content from the COOKING_METHODS and COOKING_TIPS tables.)

  # Write all topics to the food rescue content database.
  topics.each { |t| frc_db.add_topic(t) unless t.categories.empty?}
end


#############################################################################
# MAIN PROGRAM

# Argument parsing.
begin
  args = Docopt::docopt(doc, {version: version, help: true})
rescue Docopt::Exit => e
  $stderr.puts e.message
  exit -1
end


# Convert FoodKeeper products to food rescue content in a SQLite3 database.
begin
  # Create an in-memory database to avoid changing the on-disk database.
  # 
  # This connection must be kept open, because when the last connection to an in-memory database closes, its data is gone. 
  # It uses shared cache mode to allow other database connections to see the same data. 
  # See: https://www.sqlite.org/inmemorydb.html
  fk_mem_db = SQLite3::Database.new 'file::memory:?cache=shared', { results_as_hash: true }

  # Fill the in-memory database from the on-disk database.
  # See: https://www.sqlite.org/lang_vacuum.html#vacuuminto, https://stackoverflow.com/a/58932207
  fk_file_db = SQLite3::Database.new args['FK_DB'], { results_as_hash: true }
  fk_file_db.execute("VACUUM INTO 'file::memory:?cache=shared'")
  fk_file_db.close

  import_food_rescue_categories args['CSV_FILE'], fk_mem_db
  import_food_rescue_topic_intro args['CSV_FILE'], fk_mem_db

  # Database connection to the food rescue content database (the target).
  frc_db = FoodRescue::Database.new args['FRC_DB']
  frc_db.prepare_topic_tables allow_reuse: true

  # Make sure that the USDA-1 literature source is inside the target database, otherwise add it from static content.
  # 
  # @todo (later) The literature record should be inserted as a BibTeX record transformed with asciidoc-bibtex, to make sure 
  #   the right citation style is used.
  # @todo The key "USDA-1" should be blocked (defined with empty values) in the project's global bibliography.bib file so 
  #   that the content of this literature reference can be managed in this script without key conflicts.
  usda1_record = frc_db.execute "SELECT * FROM literature WHERE id = 'USDA-1' LIMIT 1"
  if usda1_record.empty?
    frc_db.execute \
      'INSERT INTO literature (id, abbrev, entry) VALUES (?, ?, ?)', 
      'USDA-1', 
      'USDA-1', 
      'Food Safety and Inspection Service of the United States Department of Agriculture: '\
        'Foodkeeper. 2017. https://play.google.com/store/apps/details?id=gov.usda.fsis.foodkeeper2' 
  end
  
  # Load each (English) FoodKeeper product and import it into the database.
  num = 1
  count = fk_mem_db.get_first_value('SELECT count() FROM PRODUCTS')
  fk_mem_db.execute('SELECT ID FROM PRODUCTS') do |product|

    puts "importing product #{num} of #{count} (ID #{product['ID']})"
    num += 1

    import_product(product['ID'], fk_mem_db, frc_db)
  end

  # @todo (later) Also load the FoodKeeper products in Spanish and Portuguese and convert them to 
  #   translated DocBook XML files.
rescue ArgumentError => e
  $stderr.puts e.message
  $stderr.puts e.backtrace
  exit -1
ensure
  fk_file_db.close if fk_file_db
  fk_mem_db.close if fk_mem_db
  frc_db.close if frc_db
end
